# leetcode总结

201. 数字范围按位与 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。
1.暴力解法，循环与
2.两个数不断同时右移直到相等

202. 快乐数 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1
1.按照定义把一个数进行转化，hash记录过程，出现重复就说明不是快乐数

203. 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点
遍历链表，遇到target就删除

204. 计数质数 输入：n = 10 输出：4  解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
定义num[10],从质数2开始，把2的倍数标记，下一个没被标记的是3，则把3的倍数标记

205. 同构字符串 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
双指针，映射关系没有就更新，有且不符合就返回false

206. 反转链表
while遍历链表，每步进行倒置
递归，倒置当前节点，递归剩下的所有节点

207. 课程表 输入：numCourses = 2, prerequisites = [[1,0]] 输出：true 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
1.每次把没有先修课的课删去，看能不能删完--等于图的bfs
2.建图，对每个节点采取dfs,看图中是否有环

208. 实现 Trie (前缀树)
实现26叉树，查找时比如d 需要找第四个子节点

209. 长度最小的子数组 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组
dp[i] = 以i结尾的连续子数组和，则 以i结尾 的最短子数组就是 dp[i] - dp[j] 最接近target

210. 课程表 II 返回你为了学完所有课程所安排的学习顺序
从没有先修课程的节点开始学，直到学完，记录学习顺序

211. 添加与搜索单词 - 数据结构设计
实现前缀树即可

212. 单词搜索 II 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。
dfs 形成前缀树，然后判断单词是否在前缀树里

213. 打家劫舍 II  第一间跟最后一间是连通的
dp[0,i] 代表抢劫 0 - i 产生的最大收益 两种情况，抢最后一间或者不抢最后一间 则收益是 max(dp[0,len-1],dp[1,len])

214. 最短回文串 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 输入：s = "aacecaaa" 输出："aaacecaaa"
从字符串中点开始往左遍历，找到回文串

215. 数组中的第K个最大元素 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
1.排序 然后遍历
2.直接遍历  过程中维护一个队列 保存k个最大的元素

216. 组合总和 III 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次
输入: k = 3, n = 7 输出: [[1,2,4]]

回溯法，从小于n的树里挑三个数
优化 双指针 固定开头1 指针为2 跟7  ，大于target 7左移直到相等，然后两个指针靠拢

217. 存在重复元素 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true
排序遍历
直接遍历 额外空间记录次数

218. 天际线问题
先输出所有区间的高度，然后对于重合的区域，进行合并，高度取高的那段，最后就形成  （1-3）高度为10.（4-6）高度为8 这样的数组
然后遍历生成答案

219. 存在重复元素 II 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。
遍历数组，把数字跟下标记录下来，遇到重复的比对下标

220. 存在重复元素 III 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。
遍历数组，把下标记录下来，每次判断之前是否出现过 <t-num[i]的数，有就比对下标

221. 最大正方形 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积
参考高度计算，先把数组转化为 节点的高度，然后以节点为右下角的边长大小就是 min(dp[m][n],dp[m][n-1]...)

222. 完全二叉树的节点个数 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数
遍历树，得到结果

223. 矩形面积 给你 二维 平面上两个 由直线构成且边与坐标轴平行/垂直 的矩形，请你计算并返回两个矩形覆盖的总面积。
确定x重合的部分，确定y重合的部分，相乘

224. 基本计算器 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。输入：s = "(1+(4+5+2)-3)+(6+8)" 输出：23
实现方法 能计算除了括号以外的内容，然后可以不断用正则取最里面的括号，计算后换回来
还可以基于栈，遇到右括号就弹出直到左括号

225. 用队列实现栈 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
题意是用两个队列实现先进后出，每次添加时添加进空队列（比如说queue2）,然后把queue1逐个取出到queue2,那此时queue2的出栈顺序就是栈的顺序

226. 翻转二叉树
定义翻转函数  root.left = fun(root.right) ,   root.right = fun(root.left)

227. 基本计算器 II 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 输入：s = " 3+5 / 2 " 输出：5
还是用栈，消除的条件是  当前入栈的是个数字，且下一个符号优先级没有比上一个高

228. 汇总区间 给定一个  无重复元素 的 有序 整数数组 nums 。返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。
遍历原列表，如果num[i]=num[i-1]+1 就连起来

229. 多数元素 II 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
遍历数组，记录出现次数

230. 二叉搜索树中第K小的元素 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
前序遍历正好从小到大

231. 2 的幂 给你一个整数 n，请你判断该整数是否是 2 的幂次方。 输入：n = 16 输出：true
不断判断最低位是否为1，是就右移

232. 用栈实现队列 请你仅使用两个栈实现先入先出队列
添加都添加到栈1，需要出栈就把栈1倒到栈2

233. 数字 1 的个数 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。
n = 5001 分析-- 个位每10个能提供一个1，十位每100个能提供一个1，百位每一千个能提供一个1，千位如果大于1则提供一个1

234. 回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表
反转链表，然后遍历两个链表进行比较
快慢指针，链表分成两半，倒置后半段 进行比较

235. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先
分情况递归
1.都小于根节点 递归右子树
2.都大于根节点 递归左子树
3.一个大一个小  返回根节点

236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先
遍历整棵树，判断节点在左子树还是右子树

237. 删除链表中的节点 有一个单链表的 head，我们想删除它其中的一个节点 node。
遍历到删除即可--但是并没有头结点，把这个节点下一个删除，值给到这个节点

238. 除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
先全部乘起来， answer[i] = 乘积/ answer[i]

239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
实现滑动窗口，使用优先队列去除旧值，添加新值

240. 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。
第一行直接确定列，在列里确定行

241. 为运算表达式设计优先级 输入：expression = "2*3-4*5" 输出：[-34,-14,-10,-10,10] 在任意位置插入括号调整优先级
一共三个运算符，排列方式为 123,132.。。  按照排列方式输出结果
栈，每次有消去栈跟不消去栈两种选择
dfs,选择就是消去还是不消去
把表达式通过运算符拆开 2 * dp[3-4*5]的结果 [-5,-17] 最终就是[-10,-34 ]

242. 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
遍历，生成字母频次，遍历第二个字符串判断
排序后判断

257. 二叉树的所有路径 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
dfs遍历














