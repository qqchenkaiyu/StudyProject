# leetcode总结

201. 数字范围按位与 给你两个整数 left 和 right ，表示区间 [left, right] ，返回此区间内所有数字 按位与 的结果（包含 left 、right 端点）。
1.暴力解法，循环与
2.两个数不断同时右移直到相等

202. 快乐数 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。然后重复这个过程直到这个数变为 1
1.按照定义把一个数进行转化，hash记录过程，出现重复就说明不是快乐数

203. 移除链表元素 给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点
遍历链表，遇到target就删除

204. 计数质数 输入：n = 10 输出：4  解释：小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。
定义num[10],从质数2开始，把2的倍数标记，下一个没被标记的是3，则把3的倍数标记

205. 同构字符串 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。
双指针，映射关系没有就更新，有且不符合就返回false

206. 反转链表
while遍历链表，每步进行倒置
递归，倒置当前节点，递归剩下的所有节点

207. 课程表 输入：numCourses = 2, prerequisites = [[1,0]] 输出：true 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
1.每次把没有先修课的课删去，看能不能删完--等于图的bfs
2.建图，对每个节点采取dfs,看图中是否有环

208. 实现 Trie (前缀树)
实现26叉树，查找时比如d 需要找第四个子节点

209. 长度最小的子数组 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组
dp[i] = 以i结尾的连续子数组和，则 以i结尾 的最短子数组就是 dp[i] - dp[j] 最接近target

210. 课程表 II 返回你为了学完所有课程所安排的学习顺序
从没有先修课程的节点开始学，直到学完，记录学习顺序

211. 添加与搜索单词 - 数据结构设计
实现前缀树即可

212. 单词搜索 II 给定一个 m x n 二维字符网格 board 和一个单词（字符串）列表 words， 返回所有二维网格上的单词 。
dfs 形成前缀树，然后判断单词是否在前缀树里

213. 打家劫舍 II  第一间跟最后一间是连通的
dp[0,i] 代表抢劫 0 - i 产生的最大收益 两种情况，抢最后一间或者不抢最后一间 则收益是 max(dp[0,len-1],dp[1,len])

214. 最短回文串 给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 输入：s = "aacecaaa" 输出："aaacecaaa"
从字符串中点开始往左遍历，找到回文串

215. 数组中的第K个最大元素 给定整数数组 nums 和整数 k，请返回数组中第 k 个最大的元素。
1.排序 然后遍历
2.直接遍历  过程中维护一个队列 保存k个最大的元素

216. 组合总和 III 找出所有相加之和为 n 的 k 个数的组合，且满足下列条件： 只使用数字1到9 每个数字 最多使用一次
输入: k = 3, n = 7 输出: [[1,2,4]]

回溯法，从小于n的树里挑三个数
优化 双指针 固定开头1 指针为2 跟7  ，大于target 7左移直到相等，然后两个指针靠拢

217. 存在重复元素 给你一个整数数组 nums 。如果任一值在数组中出现 至少两次 ，返回 true
排序遍历
直接遍历 额外空间记录次数

218. 天际线问题
先输出所有区间的高度，然后对于重合的区域，进行合并，高度取高的那段，最后就形成  （1-3）高度为10.（4-6）高度为8 这样的数组
然后遍历生成答案

219. 存在重复元素 II 给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同的索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k 。
遍历数组，把数字跟下标记录下来，遇到重复的比对下标

220. 存在重复元素 III 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) <= t ，同时又满足 abs(i - j) <= k 。
遍历数组，把下标记录下来，每次判断之前是否出现过 <t-num[i]的数，有就比对下标

221. 最大正方形 在一个由 '0' 和 '1' 组成的二维矩阵内，找到只包含 '1' 的最大正方形，并返回其面积
参考高度计算，先把数组转化为 节点的高度，然后以节点为右下角的边长大小就是 min(dp[m][n],dp[m][n-1]...)

222. 完全二叉树的节点个数 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数
遍历树，得到结果

223. 矩形面积 给你 二维 平面上两个 由直线构成且边与坐标轴平行/垂直 的矩形，请你计算并返回两个矩形覆盖的总面积。
确定x重合的部分，确定y重合的部分，相乘

224. 基本计算器 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。输入：s = "(1+(4+5+2)-3)+(6+8)" 输出：23
实现方法 能计算除了括号以外的内容，然后可以不断用正则取最里面的括号，计算后换回来
还可以基于栈，遇到右括号就弹出直到左括号

225. 用队列实现栈 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
题意是用两个队列实现先进后出，每次添加时添加进空队列（比如说queue2）,然后把queue1逐个取出到queue2,那此时queue2的出栈顺序就是栈的顺序

226. 翻转二叉树
定义翻转函数  root.left = fun(root.right) ,   root.right = fun(root.left)

227. 基本计算器 II 给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 输入：s = " 3+5 / 2 " 输出：5
还是用栈，消除的条件是  当前入栈的是个数字，且下一个符号优先级没有比上一个高

228. 汇总区间 给定一个  无重复元素 的 有序 整数数组 nums 。返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表 。
遍历原列表，如果num[i]=num[i-1]+1 就连起来

229. 多数元素 II 给定一个大小为 n 的整数数组，找出其中所有出现超过 ⌊ n/3 ⌋ 次的元素。
遍历数组，记录出现次数

230. 二叉搜索树中第K小的元素 给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。
前序遍历正好从小到大

231. 2 的幂 给你一个整数 n，请你判断该整数是否是 2 的幂次方。 输入：n = 16 输出：true
不断判断最低位是否为1，是就右移

232. 用栈实现队列 请你仅使用两个栈实现先入先出队列
添加都添加到栈1，需要出栈就把栈1倒到栈2

233. 数字 1 的个数 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。
n = 5001 分析-- 个位每10个能提供一个1，十位每100个能提供一个1，百位每一千个能提供一个1，千位如果大于1则提供一个1

234. 回文链表 给你一个单链表的头节点 head ，请你判断该链表是否为回文链表
反转链表，然后遍历两个链表进行比较
快慢指针，链表分成两半，倒置后半段 进行比较

235. 二叉搜索树的最近公共祖先 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先
分情况递归
1.都小于根节点 递归右子树
2.都大于根节点 递归左子树
3.一个大一个小  返回根节点

236. 二叉树的最近公共祖先 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先
遍历整棵树，判断节点在左子树还是右子树

237. 删除链表中的节点 有一个单链表的 head，我们想删除它其中的一个节点 node。
遍历到删除即可--但是并没有头结点，把这个节点下一个删除，值给到这个节点

238. 除自身以外数组的乘积 给你一个整数数组 nums，返回 数组 answer ，其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积 。
先全部乘起来， answer[i] = 乘积/ answer[i]

239. 滑动窗口最大值 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
实现滑动窗口，使用优先队列去除旧值，添加新值

240. 搜索二维矩阵 II 编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。
第一行直接确定列，在列里确定行

241. 为运算表达式设计优先级 输入：expression = "2*3-4*5" 输出：[-34,-14,-10,-10,10] 在任意位置插入括号调整优先级
一共三个运算符，排列方式为 123,132.。。  按照排列方式输出结果
栈，每次有消去栈跟不消去栈两种选择
dfs,选择就是消去还是不消去
把表达式通过运算符拆开 2 * dp[3-4*5]的结果 [-5,-17] 最终就是[-10,-34 ]

242. 有效的字母异位词 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
遍历，生成字母频次，遍历第二个字符串判断
排序后判断

257. 二叉树的所有路径 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
dfs遍历

258. 各位相加 给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。返回这个结果。
根据题意 通过/10右移  %10取个位，相加直到为个位数

260. 只出现一次的数字 III 给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
遍历一次，存hash计数

263. 丑数
丑数 就是只包含质因数 2、3 和 5 的正整数。给你一个整数 n ，请你判断 n 是否为 丑数
dfs 不断除以 2 或 3 或5 当结果也是2 3 5就是true

264. 丑数 II 给你一个整数 n ，请你找出并返回第 n 个 丑数 。
太难啦~

268. 丢失的数字 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。
定义boolean[] 出现2 就把boolean[2]标记为true

273. 整数转换英文表示 将非负整数 num 转换为其对应的英文表示。输入：num = 123 输出："One Hundred Twenty Three"
太难啦~ 掌握转换技巧就好

274. H 指数 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数。计算并返回该研究者的 h 指数。
h 代表“高引用次数”，一名科研人员的 h指数是指他（她）的 （n 篇论文中）总共有 h 篇论文分别被引用了至少 h 次。、
问题是求一共有6个值大于6
遍历数组，记录每个数字的频次

275. H 指数 II 给你一个整数数组 citations ，其中 citations[i] 表示研究者的第 i 篇论文被引用的次数，citations 已经按照 升序排列 。计算并返回该研究者的 h 指数。
直接遍历数组，如果 num[i]出现i次  更新h指数

278. 第一个错误的版本 其实就是在 `false false false true true`  这样的序列中找出第一次出现 `true` 的位置
二分获得第一个true的位置

279. 完全平方数 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。
求n的平方根,  dfs 减去所有可能的组合

282. 给表达式添加运算符 输入: num = "123", target = 6 输出: ["1+2+3", "1*2*3"]  解释: “1*2*3” 和 “1+2+3” 的值都是6。
dfs, 1*  dp[2,3]  1 + dp[2,3]  1-dp[2,3]
栈 数字入栈就进行计算 当前是+就看下一个，当前是*就直接乘

283. 移动零 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
遍历，遇到0就移到最后

284. 顶端迭代器 请你在设计一个迭代器，在集成现有迭代器拥有的 hasNext 和 next 操作的基础上，还额外支持 peek 操作。实现 PeekingIterator 类：
PeekingIterator(Iterator<int> nums) 使用指定整数迭代器 nums 初始化迭代器。
int next() 返回数组中的下一个元素，并将指针移动到下个元素处。
bool hasNext() 如果数组中存在下一个元素，返回 true ；否则，返回 false 。
int peek() 返回数组中的下一个元素，但 不 移动指针。

增加一个缓存变量，保存上一次next的结果用作peek的返回

287. 寻找重复数 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n），可知至少存在一个重复的整数。假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。
1.排序后遍历
2.直接遍历 记录频次
3.循环相加 最后减去 1到n的和

289. 生命游戏 给定一个包含 m × n个格子的面板， 1 即为 活细胞 （live），或 0 即为 死细胞 （dead）。
如果活细胞周围八个位置的活细胞数少于两个，则该位置活细胞死亡；
如果活细胞周围八个位置有超过三个活细胞，则该位置活细胞死亡；
如果死细胞周围正好有三个活细胞，则该位置死细胞复活；
下一个状态是通过将上述规则同时应用于当前状态下的每个细胞所形成的，其中细胞的出生和死亡是同时发生的。给你 m x n 网格面板 board 的当前状态，返回下一个状态。

遍历判断每个格子的下一个状态 ，用别的数字记录

290. 单词规律 输入: pattern = "abba", s = "dog cat cat dog"  输出: true
双指针 保存对应关系，到结束没有违反就好

292. Nim 游戏 你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头。你们轮流进行自己的回合， 你作为先手 。每一回合，轮到的人拿掉 1 - 3 块石头。
拿掉最后一块石头的人就是获胜者。假设你们每一步都是最优解。请编写一个函数，来判断你是否可以在给定石头数量为 n 的情况下赢得游戏。
我们操作后能一直保持是3的倍数即可 return n/3!=0

295. 数据流的中位数 设计一个支持以下两种操作的数据结构：
void addNum(int num) - 从数据流中添加一个整数到数据结构中。
double findMedian() - 返回目前所有元素的中位数。

使用一个最大堆，一个最小堆，维持最小堆比最大堆多一个

297. 二叉树的序列化与反序列化
序列化：遍历树append到字符串里
反序列化：遍历字符串根据序列化顺序添加到树里

299. 猜数字游戏 写出一个秘密数字，并请朋友猜这个数字是多少。朋友每猜测一次，你就会给他一个包含下述信息的提示：
猜测数字中有多少位属于数字和确切位置都猜对了（称为 "Bulls"，公牛），
有多少位属于数字猜对了但是位置不对（称为 "Cows"，奶牛）。也就是说，这次猜测中有多少位非公牛数字可以通过重新排列转换成公牛数字。
给你一个秘密数字 secret 和朋友猜测的数字 guess ，请你返回对朋友这次猜测的提示。
输入：secret = "1807", guess = "7810"
输出："1A3B"

遍历两个字符串，比较字符出现位置和频次

300. 最长递增子序列 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。
输入：nums = [10,9,2,5,3,7,101,18] 最长递增子序列是 [2,3,7,101] 最长递增子序列是 [2,3,7,101]，因此长度为 4 。
dp[i] 表示以i结尾的最长递增子序列长度 则dp[i] = max(num[1]<num[i]?dp[1]+1,num[2]<num[i]?dp[2]+1...)












