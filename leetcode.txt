# leetcode总结

1.双数之和 给定数组，找出其中两个数和为target
暴力解法O(n2) - hash优化  O(n) 
排序后双指针  O(logn)+O(n)

2.链表相加 给定两个链表，给出相加后的新链表
双指针遍历两个链表，虚拟头结点保存每一位相加结果  O(max(m,n))

3.最长不重复子字符串 给定一个字符串，找出里边一个最长的子串，此子串要求不包含任何重复字符
滑动窗口法，定义valid方法，当窗口右扩字符导致窗口不再valid,就左缩至valid  O(n)

4.找到有序数组合并后的中位数
根据合并后数组长度，决定中位数是两数除2还是某个数。比如是两数除2，用双指针的方式移到到对应位置进行计算。O((m+n)/2)

5.最长的回文子串
中心扩展法，遍历原字符串，从中心往两边扩展判断是否是回文串   O(n)* O(n) = O(n2)

6.以Z字形输出字符串 
定义几个line,遍历原字符串，根据条件判断往哪个line进行add,最后对每个line进行输出 O(n)

7.整数倒置 给定一个整数，输出倒置后的整数
1.用stringbuilder的reverse
2.%10取最后一位，/10排除最后一位，  result =  result*10+最后一位  O(logn)

8.字符串转整数 给定字符串，将其转成整数
排除不合法字符后，不断取char , result =  result*10+最后一位    O(n)

9.回文数 给定一个整数，判断是否是回文数
1.利用字符串，然后判断是否是回文串
2.利用第7题，倒置整数，判断与原来是否相等

10.正则表达匹配  给定text和pattern，pattern可能包含 .   * ，判断是否匹配
实现firstmatch,然后把问题转化为 firstmatch&match(text[1,len],pattern[1,len])
如果第二个字符是*，那问题还可能出现的情况是  *匹配0个  firstmatch&match(text[0,len],pattern[2,len]) 或者 *匹配一个 firstmatch&match(text[1,len],pattern[0,len])

11.最多的水  给定一个数组，返回任意两条边之中最多能装多少水
1.双指针放在数组两端，每次移动两条边较低的那个，不断计算当前的容量

12.数字转罗马数字  给定一个数字，将其转化为罗马数字
1.先给出罗马数字个位百位千位的表示形式，将数字的各位直接转化

13.罗马数字转数字
1.先给出罗马转数字的各个映射，然后遍历罗马数字，比如当前是n,如果map[n]>map[n+1],则res+map[n]否则-map[n].

14最长公共前缀 给定几个字符串，输出最长的公共前缀
1.多指针遍历各个字符串直至出现不同

15.三数之和  给定数组 找出其中三个数 和为target
暴力解法O(n3) - hash优化  O(n2)
排序后双指针  O(logn)+O(n2)

16.三数之和  给定数组 找出其中三个数 和最接近target
暴力解法O(n3)  排序后双指针  O(logn)+O(n2)

17.电话号码组合 给定一些手机按键（ 2代表abc, 3代表def ），按下2跟3，  输出所有可能的组合 
1.dfs,每次选择范围要根据按键获得

18.四数之和 给定数组 找出其中四个数 和为target
三数之和再加一个循环

19.移除列表里第n个值
双指针，快指针先走n步，然后两者同时步进，快指针到结尾则慢指针到第n个值

20.合法的括号匹配
1.使用栈，遇到右括号就消去栈上的左括号，看最后能不能消完

21.合并两个有序链表
参考第四题，双指针，虚拟头结点，每次添加链表头里较小的那个

22.生成括号  给定数字n,返回所有可能的括号匹配，括号数量是n
dfs,每次能选择加左括号还是右括号，但是条件是右括号数量不能超过左括号

23.k个有序链表合并 
虚拟头结点。使用优先队列，每次从队列取出头结点最小的链表，再将此链表第二个节点放入优先队列。

24.两两交换链表
双指针。
