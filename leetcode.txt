# leetcode总结

1.双数之和 给定数组，找出其中两个数和为target
暴力解法O(n2) - hash优化  O(n) 
排序后双指针  O(logn)+O(n)

2.链表相加 给定两个链表，给出相加后的新链表
双指针遍历两个链表，虚拟头结点保存每一位相加结果  O(max(m,n))

3.最长不重复子字符串 给定一个字符串，找出里边一个最长的子串，此子串要求不包含任何重复字符
滑动窗口法，定义valid方法，当窗口右扩字符导致窗口不再valid,就左缩至valid  O(n)

4.找到有序数组合并后的中位数
根据合并后数组长度，决定中位数是两数除2还是某个数。比如是两数除2，用双指针的方式移到到对应位置进行计算。O((m+n)/2)

5.最长的回文子串
中心扩展法，遍历原字符串，从中心往两边扩展判断是否是回文串   O(n)* O(n) = O(n2)

6.以Z字形输出字符串 
定义几个line,遍历原字符串，根据条件判断往哪个line进行add,最后对每个line进行输出 O(n)

7.整数倒置 给定一个整数，输出倒置后的整数
1.用stringbuilder的reverse
2.%10取最后一位，/10排除最后一位，  result =  result*10+最后一位  O(logn)

8.字符串转整数 给定字符串，将其转成整数
排除不合法字符后，不断取char , result =  result*10+最后一位    O(n)

9.回文数 给定一个整数，判断是否是回文数
1.利用字符串，然后判断是否是回文串
2.利用第7题，倒置整数，判断与原来是否相等

10.正则表达匹配  给定text和pattern，pattern可能包含 .   * ，判断是否匹配
实现firstmatch,然后把问题转化为 firstmatch&match(text[1,len],pattern[1,len])
如果第二个字符是*，那问题还可能出现的情况是  *匹配0个  firstmatch&match(text[0,len],pattern[2,len]) 或者 *匹配一个 firstmatch&match(text[1,len],pattern[0,len])

11.最多的水  给定一个数组，返回任意两条边之中最多能装多少水
1.双指针放在数组两端，每次移动两条边较低的那个，不断计算当前的容量

12.数字转罗马数字  给定一个数字，将其转化为罗马数字
1.先给出罗马数字个位百位千位的表示形式，将数字的各位直接转化

13.罗马数字转数字
1.先给出罗马转数字的各个映射，然后遍历罗马数字，比如当前是n,如果map[n]>map[n+1],则res+map[n]否则-map[n].

14最长公共前缀 给定几个字符串，输出最长的公共前缀
1.多指针遍历各个字符串直至出现不同

15.三数之和  给定数组 找出其中三个数 和为target
暴力解法O(n3) - hash优化  O(n2)
排序后双指针  O(logn)+O(n2)

16.三数之和  给定数组 找出其中三个数 和最接近target
暴力解法O(n3)  排序后双指针  O(logn)+O(n2)

17.电话号码组合 给定一些手机按键（ 2代表abc, 3代表def ），按下2跟3，  输出所有可能的组合 
1.dfs,每次选择范围要根据按键获得

18.四数之和 给定数组 找出其中四个数 和为target
三数之和再加一个循环

19.移除列表里第n个值
双指针，快指针先走n步，然后两者同时步进，快指针到结尾则慢指针到第n个值

20.合法的括号匹配
1.使用栈，遇到右括号就消去栈上的左括号，看最后能不能消完

21.合并两个有序链表
参考第四题，双指针，虚拟头结点，每次添加链表头里较小的那个

22.生成括号  给定数字n,返回所有可能的括号匹配，括号数量是n
dfs,每次能选择加左括号还是右括号，但是条件是右括号数量不能超过左括号

23.k个有序链表合并 
虚拟头结点。使用优先队列，每次从队列取出头结点最小的链表，再将此链表第二个节点放入优先队列。

24.两两交换链表
交换两个节点，需要三个指针。在图上画出交换过程，最后把第一个指针位置前进两个，继续交换后面。

25.将链表每k个倒置
编写倒置链表函数（一次遍历O(n)），把原链表按照k个一组拆下来倒置再接回去。

26.去除数组里的重复数字
1.双指针放在数组两端，left遍历数组，遇到重复就把当前数字跟right--交换

27.去除数组里的给定元素 从数组里删除一个给定的树
1.遍历数组，遇到target就换到最后一位

28.实现indexOf  给定两个字符串，返回第二个字符串在第一个字符串的位置
双指针，用charAt进行比较，一样就两个指针一起后移，长度够了就返回

29 实现除法
按照手算的规则，用算法实现

30. 串联所有单词的子串 给定一个字符串，跟一个子串数组，每个子串长度一致，要求从一个字符串找到子串包含第二个数组的所有内容
编写函数判断子串是否valid，遍历第一个字符串，遇到符合的子串就记录。

31.下一个排列 给一个排列比如123  下一个比他大的是132
从右往左，如果text[i]右边有比它大的，就放到i的位置，然后把右边排个序从小到大

32.最长的有效括号 给一个字符串)()())，找出里面最长的有效括号
用栈，每次发生消除就把消除过后栈顶计数增加，结束后遍历，输出最大的计数

33. 搜索旋转排序数组 给定数组[4,5,6,7,0,1,2]，从中找target
从中位数划分数组，两边必有一个有序，用二分对有序数组进行搜索，如果找不到就再划分无序数组

34. 在排序数组中查找元素的第一个和最后一个位置 输入：nums = [5,7,7,8,8,10], target = 8
二分搜索数字，找到后，如何确定第一个位置？在左边数组二分查找target，如果没有自己就是第一个，有就重复上述过程

35. 搜索插入位置 nums = [1,3,5,6], target = 2
直接用二分定位位置即可

36. 有效的数独 数独有效意味着每行每列，每个小方块都不重复，判断给定数组是否是有效的数独
1.按照题意暴力破解   使用hash进行优化（第二行有个3，写作2行3添加进hash，这样后续添加3的时候不用一个个判断了）

37. 解数独
定义方法valid,判断当前是否是合法数独，用dfs在棋盘输入任意的数字

38. 外观数列 给定一个正整数 n ，输出外观数列的第 n 项 描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"
定义函数根据一个字符串生成外观字符串，执行n次

39. 组合总和  找出数字里所有能组合成target的选项   candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]]
回溯法，每次选择就是整个数组
fun(arr,8) = 2+each(fun(arr,6)) +  3+each(fun(arr,5)) + 5+each(fun(arr,3))

40. 组合总和 II 与上一题相同，但是不能选重复元素
回溯法，每次选择就是整个数组除去刚刚选的

41. 缺失的第一个正数 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 nums = [2,1,0] 输出：3
使用一个boolean[],比如遇到2 就boolean[2] = true,结束遍历数组找到第一个false

42. 接雨水 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1],数组值代表高度，返回这个数组能接多少雨水
一列一列求，每一列能接的雨水等于 = min(左边最高,右边最高) - 当前高度

43 字符串相乘
按照乘法规则进行计算

44. 通配符匹配  给定text和pattern，pattern可能包含 ?  * ，判断是否匹配
参考第十题

45. 跳跃游戏 II 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。用最少步数跳到最后
贪心算法，每次要跳的时候，从能跳的里面选择能跳的最多的，比如能跳2格,第一格是5，那辐射范围能到5+1，第二个是3，那辐射范围只有3+2，选第一格

46. 全排列 输入：nums = [1,2,3]  输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
回溯法 每次选择数组里还没被选择过的

47. 全排列 II 输入：nums = [1,1,2] 输出： [[1,1,2], [1,2,1],[2,1,1]]
回溯法，按照上一题，选择数组里还没被选过且没重复的

48. 旋转图像
定义旋转，先按照对角线转（交换 matrix[i][j] 跟 matrix[j][i];），再按照中线转

49. 字母异位词分组 把相同字母的字符串分为一组 输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"] 输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
重点就是如何把异位词定位到相同的位置，可以按照字母顺序先排序后进行映射

50. Pow(x, n) 实现 x的n次的计算
暴力解： x循环相乘  优化 Pow(x, n)  = Pow(x, n/2) * Pow(x, n/2)

51. N 皇后
回溯法，每次选择完下一步皇后位置，用valid函数检查是否有效

52. N皇后 II 给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量
与上一题相同，返回size

53. 最大子数组和 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 连续子数组 [4,-1,2,1] 的和最大，为 6 。
定义dp[i]为以i结尾的子数组的最大和，则dp[i] = num[i] + dp[i-1]>0?dp[i-1]:0;

54. 螺旋矩阵 给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。
按照向右-向下-向左-向上的顺序遍历矩阵，到边界后就换方向同时把此方向边界移动一层

55. 跳跃游戏 判断能否到达最后一个下标
1.按照45题的思路先跳，看最后的辐射范围能否超过最后一个下标
2.每个最远能到num[i]+i,遍历数组存在j使得左边所有位置的跳跃距离都没超过j则跳跃失败

56. 合并区间
先将区间根据start进行排序，定义方法，在一个已合并过的区间内添加新的区间

57. 插入区间
定义方法，在一个已合并过的区间内添加新的区间

58. 最后一个单词的长度 输入：s = "luffy is still joyboy" 最后一个单词是长度为6的“joyboy”。
从字符串倒着遍历就好

59. 螺旋矩阵 II 按照螺旋顺序生成1-n2,比如 1-9
参考54，遍历空数组，每次都赋值

60. 排列序列 给定 n 和 k，返回第 k 个排列
分治法 ，dp[list{1--n},k] = 首位数字+ dp[list{1--除去首位数字--n},k-首位数字*每组数量]

61. 旋转链表 给你一个链表的头节点 head ，旋转链表，将链表每个节点向右移动 k 个位置。
找到第k个位置，然后断开接到头结点

62. 不同路径 一个机器人位于一个 m x n网格的左上角 ，机器人每次只能向下或者向右移动一步。到达右下角一共有几种走法
定义dp[m][n] 是走到此单元格的走法，则dp[m][n] = dp[m-1][n] + dp[m][n-1]

63. 不同路径 II 某个单元格不能走
dp[某个值][某个值]永远为0

64. 最小路径和 给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
定义dp[m][n] 是走到此单元格的最小路径和，则dp[m][n] = min(dp[m-1][n] + dp[m][n-1])+grid[m][n]

65. 有效数字
根据定义完成状态机编写，这题主要要读懂题意

66. 加一 输入：digits = [1,2,3] 输出：[1,2,4]
最后一位加一，有进位的话倒数第二位继续加

67. 二进制求和 给你两个二进制字符串 a 和 b ，以二进制字符串的形式返回它们的和。
从右往左，双指针遍历字符串，结果写到新字符串里

68. 文本左右对齐
两种添加模式 最后一行和不是最后一行， 从原文本逐个选单词添加进当前行直到超出，就换到下一行

69. x 的平方根
二分查找，比如8，从4开始，4的平方16大于8，则mid=2

70. 爬楼梯 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
定义f(n)为爬到n的方法种数，则f(n) = (f(n-1) + 1) + (f(n-2) + 1)

71. 简化路径 输入：path = "/home//foo/" 输出："/home/foo"
用栈，遇到字母就入栈，遇到..就出栈

72. 编辑距离
定义dp[i][j] 代表 word1 到 i 位置转换成 word2 到 j 位置需要最少步数
当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]；
当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1


73. 矩阵置零 给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地 算法。
如果遍历到0就直接把所在行和列变成0，会影响后续判断，所以只能记在第一行跟第一列的对应位置，
那么这样就用两个变量记录第一行跟第一列有没有0这个信息，记录了以后第一行跟第一列就能先用来记录其他行跟列的信息了

74. 搜索二维矩阵 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性
基于二分搜索，先二分定位行，再二分定位列

75. 颜色分类 输入：nums = [2,0,2,1,1,0] 输出：[0,0,1,1,2,2]
双指针进行交换

76. 最小覆盖子串 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串
滑动窗口，定义valid函数

77. 组合 给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合
回溯法，长度为k就终止，选择列表为 [1, n] 减去已选

78. 子集 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集） 输入：nums = [1,2,3]  输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
1. 利用77题的思路，给出所有可能
2.回溯法，选择只选比自己大的，把过程中路径也算上
3.位运算，用 000 代表【】,111代表【1,2,3】 ,逐步得到结果

79. 单词搜索 给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true
dfs,定义方法计算从grid[i][j]能不能找到单词word

80. 删除有序数组中的重复项 II 给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使得出现次数超过两次的元素只出现两次
双指针，如果left遇到重复项就换到最后一位

81. 搜索旋转排序数组 II
比起之前的题目，差别在于怎么判断左边的数组是否是有序数组，如果arr[0]=arr[mid] ,则移动左边界看arr[1] 跟arr[mid]

82. 删除排序链表中的重复元素 II 给定一个已排序的链表的头 head ， 删除原始链表中所有重复数字的节点，只留下不同的数字
从左到右遍历,遇到重复就删除当前节点跟上一个节点

83. 删除排序链表中的重复元素 给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次
从左到右遍历,遇到重复就删除当前节点

84. 柱状图中最大的矩形
一列列求以当前列为高度的矩形
定义dp[i]表示i下标的柱子，左边比他高的连着有几个,则dp[i] = num[i]<num[i-1]?dp[i-1]+1:1;
再定义dpp[i]表示右边高的有几个，综合来算面积

85. 最大矩形 给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形
dp[m][n]记录横向左边有多少个1
遍历所有点，对于每个点计算不同高度的矩形面积，高度为2的面积就是 2 * min[dp[m][n],dp[m][n-1]]

86. 分隔链表 给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前
快速排序的思想,双指针,两边同时向中间靠拢，当出现左边大于x,而右边小于x则交换
对于链表双指针，left记录待交换位置，right不断往后，遇到小于x的数就换去left的位置

87. 扰乱字符串
a与b互为扰乱字符串，设分割点为i,
两种比法 不交换 a(0,i)对比b(0,i)，交换 a(len-i,len)对比b(0,i)
f(a,b) = f(a(0,i),b(0,i))&f(a(i,len),b(i,len)) 或者 f(a(len-i,len),b(0,i))&f(a(0,len-i),b(i,len))

88. 合并两个有序数组
两个指针，不断取小的那个就好

89. 格雷编码 给你一个整数 n ，返回任一有效的 n 位格雷码序列
递归，知道n=2的解就能得到n=3的解，在纸上画出结果会发现规律，n=3就是在n=2的基础上，镜像到下半部分最高位是1.

90. 子集 II 给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集
回溯法 把路径也加到结果，选择不要选选过的，最后的结果进行去重

91. 解码方法 输入：s = "12" 输出：2  解释：它可以解码为 "AB"（1 2）或者 "L"（12）
dp[s] = dp[s.sub(1,len)] +  dp[s.sub(2,len)]// 如果两个数不超过26

92. 反转链表 II
给你单链表的头指针 head 和两个整数left 和 right  。请你反转从位置 left 到位置 right 的链表节点
定义反转链表方法，双指针走到left跟right把中间的断开反转再接回来

93. 复原 IP 地址 输入：s = "25525511135"  输出：["255.255.11.135","255.255.111.35"]
回溯法，每次选1-3位，选4次

94. 二叉树的中序遍历 给定一个二叉树的根节点 root ，返回 它的 中序 遍历
左中右

95. 不同的二叉搜索树 II 给你一个整数 n ，请你生成并返回所有由 n 个节点组成且节点值从 1 到 n 互不相同的不同 二叉搜索树
定义方法 f(i,j)表示生成从i到j所有可能的二叉搜索树，则 3为节点，左子树是f(1,2),右子树是f(4,n)

96. 不同的二叉搜索树 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数
定义方法 f(i,j)表示生成从i到j所有可能的二叉搜索树种数 则 3为节点 种数是 左子树是f(1,2)*右子树是f(4,n)

97. 交错字符串 给定三个字符串 s1、s2、s3，请你帮忙验证 s3 是否是由 s1 和 s2 交错 组成的 输入：s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac" 输出：true
双指针，每次从前两个字符串取一个，如果取不出来就返回false

98. 验证二叉搜索树
定义方法f(root) 表示root是否是二叉搜索树，定义方法max(root)得到最大值，则根据定义 f(root) = f(root.left)&f(root.right)&max(root.left)<root&min(root.right)>root)

99. 恢复二叉搜索树 给你二叉搜索树的根节点 root ，该树中的 恰好 两个节点的值被错误地交换。请在不改变其结构的情况下，恢复这棵树 。
分情况
左树节点跟root节点换了 特征 root小于 max(left)
右树节点跟root节点换了  特征 root大于 min(right)
左数节点跟右树节点换了  特征 root小于 max(left) 且 root大于 min(right)
交换问题节点

100. 相同的树 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同
同时遍历两棵树，判断每个节点是否相等
