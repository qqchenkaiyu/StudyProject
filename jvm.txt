内存区域: 堆栈 程序计数器 本地方法栈 方法区（1.8以前的实现是永久代 1.8改成元空间 使用堆外内存）
堆空间：根据Gc分为老年代和新生代（Eden,from,to（8:1:1））

加载类的过程：先查看元空间是否加载过，如果没有就进行加载(获取二进制流，生成class对象放在方法区)，解析，
初始化（分配内存空间（指针碰撞：指针右移对象大小的空间 空闲列表：jvm记录各个内存块空闲大小） 内存赋零值），设置对象头（对象分代年龄，锁状态，元数据位置）

分配对象会发生抢占，方案1 用CAS进行分配重试，方案2 线程在堆里预先分配一小段内存
java对象访问分为句柄访问（变量表--->(类型指针，对象指针--->(对象数据))）跟直接指针访问（变量表--->(类型指针，对象数据)）
java中的对象引用：强引用，软引用（空间不够就回收），弱引用（发现就回收），虚引用（只能记录回收）
内存回收算法：标记清除，标记复制，标记整理（内存向一端移动）
新生对象默认在eden区分配，不够就发生younggc,会把eden+from里存活对象移动到to,然后清空eden+from,交换from跟to
代码只有运行到安全点才能stw,安全点包括（循环结束，方法执行返回，可能抛异常的位置）

CMS分为四步：
初始标记-stw,单线程标记root
并发标记-多线程遍历root标记对象
重新标记-stw,多线程标记上述过程中新产生的对象
并发清除-多线程清理（标记清除）
G1分为4步：前三步与CMS一样，最后的清除阶段，划分不同region,采用标记复制(解决CMS碎片过多)，需要STW
对象一定分配在堆中吗？经过逃逸分析，如果对象生命周期只在方法里，可以分配在栈中（逃逸分析还可以把方法中的对象同步措施消除）
线上CPU过高怎么排查：top命令定位进程，top -hp 定位线程,jstack 29452 > 29452.txt 分析线程执行情况
内存过高怎么排查：jstat -gc 观察gc情况，如果每次回收对象多说明只是分配快，每次回收对象少说明可能发生泄露。
双亲委派：加载string.class时按照顺序询问父类是否加载。结构依次是自定义加载器-系统加载器（应用程序加载器）-扩展类加载器-启动类加载器
如何破坏双亲委派机制：重写loadclass方法
