redis是什么 可以用来做什么
redis是一款基于内存的nosql数据库
有多种数据结构
string 底层sds基于C语言字符串做了优化，多存了length属性，支持扩容。场景用于存取json对象，计数器，分布式锁
hash 可用于购物车
list  实现队列，栈
set 实现去重，交集（共同好友/粉丝），随机取出一个元素(抽奖)
sortedset 元素具有分值 用于排行榜，延时队列

bitmap 布隆过滤器
hyperloglog
geo 存地理位置 计算距离，实现附近的人功能
支持以下持久化方式
aof 记录每次更新命令，文件过大时需要进行重写（从redis数据库读取所有键值进行写入），有aof优先用aof恢复，根据不同策略刷盘（每次都刷或 每秒一次 或由系统决定）
rdb 快照，实时性查，恢复快，用于数据备份 save(阻塞保存) bgsave(异步保存)
混合持久化 生成的aof文件包含rdb内容和增量aof内容

redis为什么快
1.单线程减少线程切换上下文（现在6.0版本 socket读写也用多线程）
2.底层优化数据结构
3.网络采用reactor模型
4.完全基于内存

redis主从同步/哨兵机制
通过slave of null命令可以指定节点为主节点,slave of xx 就是从节点，从节点也可以是其他从节点的主节点，减少真正主节点的复制压力（最好采用链表结构 master<-slave1<-slave2
 主节点挂了只需要动slave1其他不变 持久化影响性能所以主节点关闭持久化）
初次复制时从节点连接上主节点，主节点重新生成rdb发送给从节点，从节点删除旧数据，恢复rdb数据，跟主节点这期间收到放在缓冲区里的更新命令
缺点：主节点故障需要人工恢复
使用哨兵完成自动故障恢复，哨兵会在主节点故障时先把自己选为哨兵主节点（首个发现主观下线的节点向其他节点问询自己能否成为哨兵主节点，其他节点如果之前没有同意过则同意，
当收到超过m个同意后当前节点成为哨兵主节点），选举新的数据主节点（过滤不健康的节点，选择从节点优先级最高的节点，如果没有选择当前复制偏移量最靠前的节点），然后通过命
令slave of 进行主节点替换。哨兵通过定时任务（主从信息获取，哨兵信息发布，心跳检测）监控节点状态，认定主节点主观下线后，
询问其他哨兵意见如果超过m个哨兵认可主节点下线才是客观下线。

redis集群机制
至少3主3从，主节点可读可写，发生故障从节点可自动成为主节点。可通过扩容提升容量
数据分区：数据根据hash,分为16384个槽，集群扩缩容时就是把对应的槽内容进行复制转移。
故障发现：所有节点承担故障发现任务，当ping不通某个节点就标记主观下线并告知其他节点，如果超过m个节点认可下线就是客观下线。

缓存击穿缓存穿透缓存雪崩
都是大量查询没命中缓存直接到数据库
缓存击穿：一个热点key过期  热点key设置不过期，只让一个线程进行缓存更新
缓存雪崩：大量key同时过期 过期时间离散，如果由于缓存挂掉引起就要使用redis集群避免
缓存穿透：故意查不存在的key 参数校验，缓存空值，布隆过滤器

缓存与数据库一致性
最常用的方案是更新数据的时候先更新数据库再删除redis的key(为了减少更新频率)
如果先删redis再更新数据库则由于并非原子操作，更新数据库前其他线程可能把脏数据缓存进redis
如果先更新数据库在删除redis的时候失败，会造成数据不一致，建议重新删除或者发送到消息队列重试删除。数据过期时间不要太长

如何保证jvm缓存跟redis缓存一致：
删除redis key的时候发送消息队列，本地也进行删除

热key问题解决
jvm缓存 通过在key后面加随机数进行打散，达到读负载均衡

热点key重建过程
1.物理上设置不过期
2.功能上设置逻辑过期时间，然后只允许单个线程查询db进行缓存重建

redis内存回收
惰性删除：get时发现过期删
定期删除：从设置了过期的dict中定时抽取部分key删除
其余的在内存不足时采用lru删除

redis阻塞问题排查
查询slowlog 替换高复杂度命令，把大对象拆散成小对象
查询cpu 看看是否需要扩集群
持久化 aof刷盘默认每秒一次如果fsync()调用时间超过1s且距离上次调用超过2s则主线程会阻塞住。

大key问题
分析大key可以通过分析rdb文件防止bigkeys命令阻塞生产环境
拆散大key,string类型可以通过压缩或拆分对象，list类型可以进行分片

redis事务
redis事务只是把命令都不执行进行缓存，直到服务器收到exec命令一起执行，如果中途失败，后续命令不会执行，执行过的命令不会回滚
还有其他方式可以打包命令：lua脚本，pipeline

redis基础结构
sds,
linkedlist,
dict 分为两个table ht[0]和 ht[1]   每次dictFind会把执行一次rehash(一次rehash就是把ht[0]里的某个bucket移到ht[1],如果移动完就把ht[1]变成ht[0],ht[1]清空)
skiplist 每个节点有多个指针指向其他节点（level3 指向节点17，level 1指向节点8 这样），使用的原因（容易理解，输出区间 大于某个值 效率比红黑树更快，因为定位起始节点后可直接向后遍历）
intset
ziplist 连续内存块，起始字节说明块大小 zlbytes<-zltail<-entry<-entry<-zlend
quicklist就是linkedlist但是节点值不是void*而是ziplistnode

redis找到某个前缀的key
使用scan不停翻页（keys命令会阻塞），需要去重

redission实现的分布式锁效率更高，watchdog机制在使用默认30秒超时的前题下会用一个定时任务每10秒检测一次延长锁时间，
每次加锁解锁都通过lua脚本，通过订阅锁释放消息减少重复获取锁的消耗。
