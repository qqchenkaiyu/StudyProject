# leetcode总结

101. 对称二叉树 给你一个二叉树的根节点 root ， 检查它是否轴对称。
定义方法判断是否是对称二叉树 -- 即 left=right &&  left.left对称于right.right  && left.right对称于right.left

102. 二叉树的层序遍历  给你二叉树的根节点 root ，返回其节点值的 层序遍历 
BFS代码，遍历每层前用size记录当前层数量

103. 二叉树的锯齿形层序遍历 给你二叉树的根节点 root ，返回其节点值的 锯齿形层序遍历 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）
BFS代码，添加的时候可以用list.addhead控制方向

104. 二叉树的最大深度 给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数
BFS代码 记录当前深度

105. 从前序与中序遍历序列构造二叉树 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。
输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7]
递归构造树，  root =3,  root.left = generate[ 9    9]        root.right = generate[ 20,15,7      15,20,7]

106. 从中序与后序遍历序列构造二叉树 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7]
 递归构造树，  root =3,  root.left = generate[ 9    9]        root.right = generate[15,7,20     15,20,7]
 
107. 二叉树的层序遍历 II 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
BFS代码，添加到链表

108. 将有序数组转换为二叉搜索树 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
root = array[mid]  left=generate(0,mid) right=generate(mid,len)

109. 有序链表转换二叉搜索树 给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。
参考108题，用arraylist记录链表然后转化问题

110. 平衡二叉树 给定一个二叉树，判断它是否是高度平衡的二叉树。
BFS代码，判断最短深度跟最大深度的差

111. 二叉树的最小深度 给定一个二叉树，找出其最小深度。
BFS找到最小深度

112. 路径总和 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。
回溯法走遍所有路径,如果到叶子节点相等就返回true

113. 路径总和 II 给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。
回溯法走遍所有路径,如果到叶子节点相等就记录

114. 二叉树展开为链表
给你二叉树的根结点 root ，请你将它展开为一个单链表：展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。展开后的单链表应该与二叉树 先序遍历 顺序相同。
定义函数拉直root,  把左子树拉直后放到右子树上，再把右子树拉直

115. 不同的子序列 给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，"ACE" 是 "ABCDE" 的一个子序列，而 "AEC" 不是）
定义dp[s][t]为在 s 的子序列中 t 出现的个数  分情况
若s[0]!=t[0]   dp[s][t] = dp[s.substr(1)][t]
若s[0]=t[0]   dp[s][t] = dp[s.substr(1)][t.substr(1)] +  dp[s.substr(1)][t]

116. 填充每个节点的下一个右侧节点指针 给定一个 完美二叉树 填充它的每个 next 指针，让这个指针指向其下一个右侧节点
BFS,每层节点用next连接

117. 填充每个节点的下一个右侧节点指针 II 给定一个二叉树 填充它的每个 next 指针，让这个指针指向其下一个右侧节点
BFS,每层节点用next连接

118. 杨辉三角 给定一个非负整数 numRows，生成「杨辉三角」的前 numRows 行。
定义函数，根据一行生成下一行路径

119. 杨辉三角 II 给定一个非负索引 rowIndex，返回「杨辉三角」的第 rowIndex 行。
定义函数，根据一行生成下一行

120. 三角形最小路径和 给定一个三角形 triangle ，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。
参考二叉树的最小路径和，用回溯法走遍三角形，记录走到底层的最小路径和
定义dp[i]为父节点最小路径和+num[i]

121. 买卖股票的最佳时机  给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
暴力解法 O(n2)
把数组转化为相对前一天的涨幅，则问题就是求最大区间和

122. 买卖股票的最佳时机 II  给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。返回 你能获得的 最大 利润 。
把数组转化为相对前一天的涨幅，把所有利润相加

123. 买卖股票的最佳时机 III  给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
定义dp[i][k]表示 以i结尾 交易k次的最大收益 
当天进行了交易   那在0-i中还有一次买入   设为j     dp[i][k] = dp[j][k-1] +  price[i]-price[j]
 当天没进行交易  dp[i][k] = dp[i-1][k]
 
124. 二叉树中的最大路径和 路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。
路径和 是路径中各节点值的总和。给你一个二叉树的根节点 root ，返回其 最大路径和 
定义函数计算经过节点的单边最大路径和，  整个结果就是  max(left)+max(right)+root;

125. 验证回文串  给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。
翻转然后对比    或者双指针向中间靠拢对比

126. 单词接龙 II
输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]
解释：存在 2 种最短的转换序列：
"hit" -> "hot" -> "dot" -> "dog" -> "cog"
"hit" -> "hot" -> "lot" -> "log" -> "cog"
bfs  每次把选取只差一个单词的加入下一层 ，输出最小层数

127. 单词接龙 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列 beginWord -> s1 -> s2 -> ... -> sk：
给你两个单词 beginWord 和 endWord 和一个字典 wordList ，返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0 
 bfs  每次把选取只差一个单词的加入下一层 ，输出最小层数
 
128. 最长连续序列
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
定义dp[i]是i结尾的最长序列   dp[i] = for(0,i).filter(num[j]<num[i]).map(dp[j]+1).max

129. 从根节点到叶节点的路径 1 -> 2 -> 3 表示数字 123 。 计算从根节点到叶节点生成的 所有数字之和 。
dfs,和累加

130. 被围绕的区域 给你一个 m x n 的矩阵 board ，由若干字符 'X' 和 'O' ，找到所有被 'X' 围绕的区域，并将这些区域里所有的 'O' 用 'X' 填充。
从边上的O进行遍历，把遍历到的标记为A,然后把所有未标记的O改成X,把A改回来

131. 分割回文串 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是 回文串 。返回 s 所有可能的分割方案。
回溯法 每次选择分割方案，割超过一个字母的时候需要确保这个子串是回文串

132. 分割回文串 II 给你一个字符串 s，请你将 s 分割成一些子串，使每个子串都是回文。 返回符合要求的 最少分割次数 。
定义dp[text]是最少分割次数  dp[text] = min(dp[text.sub(1),dp[text.sub(2)//当前两个是回文  。。。。]])+1

133. 克隆图
给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。
第一次BFS，把所有遍历到的节点放进set  第二次BFS,把所有节点更新邻节点

134. 加油站 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
定义新的数组记录gas-cost[-2,-2,-2,3,3] 从此数组正数的地方开始遍历，看能否回到此正数

135. 分发糖果
n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 ratings = [1,0,2] ratings = [1,2,2]
你需要按照以下要求，给这些孩子分发糖果：
每个孩子至少分配到 1 个糖果。
相邻两个孩子评分更高的孩子会获得更多的糖果。
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。
初始化一个都为1 的糖果数组，遍历原数组，如果 num[i]属于凸起，则给糖果数组+1

136. 只出现一次的数字 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。输入: [2,2,1] 输出: 1
简单做法：hash做额外空间，遍历完后根据hash记录的输出结果
排序后，从左往右遍历也行

137. 只出现一次的数字 II 给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。
你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题
简单做法：hash做额外空间，遍历完后根据hash记录的输出结果

138. 复制带随机指针的链表 给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点。构造这个链表的 深拷贝。
第一次遍历构造普通链表，第二次遍历 复制随机指针

139. 单词拆分
给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。
回溯法 dp[s,wordDict] = dp[s.substr(3),wordDict.remove(xxx)]|| dp[s.substr(4),wordDict.remove(xxxx)]

140. 单词拆分 II
给定一个字符串 s 和一个字符串字典 wordDict ，在字符串 s 中增加空格来构建一个句子，使得句子中所有的单词都在词典中。以任意顺序 返回所有这些可能的句子。
注意：词典中的同一个单词可能在分段中被重复使用多次。
回溯法 dp[s,wordDict] = dp[s.substr(3),wordDict]|| dp[s.substr(4),wordDict]

141. 环形链表 给你一个链表的头节点 head ，判断链表中是否有环。
hash保存走过的节点，如果再走到就是有环
快慢指针，如果相遇就是有环

142. 环形链表 II 给定一个链表的头节点  head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
 hash保存走过的节点，如果再走到就是有环
快慢指针，如果相遇就是有环  相遇点就是入环点

143. 重排链表
给定一个单链表 L 的头节点 head ，单链表 L 表示为：
L0 → L1 → … → Ln - 1 → Ln
请将其重新排列后变为：
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
先获得倒置的链表，然后双指针构建新的链表

144. 二叉树的前序遍历 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。
中左右

145. 二叉树的后序遍历 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 
左右中

146. LRU 缓存 请你设计并实现一个满足  LRU (最近最少使用) 缓存 约束的数据结构。
1.使用linkedHashMap实现
2.linkedlist+hashmap实现 entry添加pre after属性

147. 对链表进行插入排序 给定单个链表的头 head ，使用 插入排序 对链表进行排序，并返回 排序后链表的头 。
根据插入排序的定义，每次即将插入时，遍历链表找到要插入的位置

148. 排序链表
给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表
遍历原链表，放进优先队列，生成新链表

149. 直线上最多的点数 给你一个数组 points ，其中 points[i] = [xi, yi] 表示 X-Y 平面上的一个点。求最多有多少个点在同一条直线上。
基于每个点进行回溯，结果针对相同的kx+y进行缓存

150. 逆波兰表达式求值 根据 逆波兰表示法，求表达式的值。 有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。
输入：tokens = ["2","1","+","3","*"] 输出：9 解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
栈，遇到计算符号就弹出计算塞回去

151. 反转字符串中的单词 输入：s = "the sky is blue" 输出："blue is sky the"
倒序遍历

152. 乘积最大子数组 （非空连续） 输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。
dp[i]表示i结尾的乘积最大子数组  则dp[i] = num[i]*dp[i-1]>1?dp[i-1]:1

153. 寻找旋转排序数组中的最小值
二分，如果有一边不是递增，则最小值在这一边

154. 寻找旋转排序数组中的最小值 II （相比上一题 可能存在重复）
 二分，如果有一边不是递增，则最小值在这一边
 
155. 最小栈 实现put pop getmin
栈用java 栈实现，最小值单独用一个栈  入栈条件是新元素更小，出栈条件是元素相等。

160. 相交链表 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null
遍历第一个链表，存到hash里，再遍历第二个

162. 寻找峰值 峰值元素是指其值严格大于左右相邻值的元素。
dp[i]代表i相对i-1 的涨幅 则题目转换为 正数到负数这样的组合

164. 最大间距 给定一个无序的数组 nums，返回 数组在排序之后，相邻元素之间最大的差值 。如果数组元素个数小于 2，则返回 0 。
