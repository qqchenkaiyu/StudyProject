Arraylist扩容是1.5倍，数组用transient修饰，序列化是重写readObject/writeObject方法，根据属性size把对象写入流
快速失败：java.util包下的集合类都是快速失败的，遍历时发现其他线程的修改，modCount！=expectedmodCount 就会立刻抛出异常
安全失败：java.util.concurrent包下的容器都是安全失败，遍历时会拷贝集合内容进行遍历
hashmap原理：1.7以前是数组+链表，采用头插法多线程容易死循环，1.8为数组+链表+红黑树，改为尾插。链表长度大于8且数组长度大于64则变为红黑树，红黑树长度缩小至6会变回链表
1.8扩容机制优化：因为会扩容成2的整数幂，等于hash取模时多1bit,根据那1bit是否是1决定是否要移动到新的下标
set方法：根据key.hash与数组长度取模确定下标，与链表逐个根据equals比对,找到就更新，没有就插入到尾节点
为什么用红黑树：平衡的二叉树，避免极端情况劣化成链表，又没有严格平衡，旋转次数比起平衡二叉树更低。
长度为啥是2的整数幂：这样n-1 正好是地位掩码，比如16-1=  0000 1111，正好取最低4位，初始化传17的话会找到比17大的最小2的证书幂32
扰动函数：key.hashcode得到int,高16位与低16位进行异或
ConcurrentHashmap实现：
1.7分段锁，分16个segment（继承lock,内部是entrylist）,最大并发度是16
1.8对每一个数组节点用cas+synchronized加锁，结构是数组+链表+红黑树，cas用来初始化数组和头结点，链表跟红黑树操作（put）是synchronized锁头结点
